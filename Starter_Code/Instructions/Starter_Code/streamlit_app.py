# -*- coding: utf-8 -*-
"""Streamlit_App

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HctfX5DOJ9RRTdcCTNXWW4xs-4TEkWeh
"""

pip install --upgrade streamlit

def my_func(arg1, arg2):
    # function body
    return result

pip install ngrok

pip install pyngrok

pip install blockchain

pip install PyChain

pip install transaction

pip install backend

pip install chain

pip install record

# Imports
import streamlit as st
from dataclasses import dataclass
from typing import Any, List
import datetime as dt
import pandas as pd
import hashlib
import builtins
import backend
import transaction
import types
import inspect
from functools import lru_cache

def main():
    st.title("My Streamlit App")
    st.write("Hello, world!")
    
if __name__ == "__main__":
    main()

# Create a Record Data Class
@dataclass
class Record:
    sender: str
    receiver: str
    amount: float

# Modify the Existing Block Data Class to Store Record Data

# Rename the `data` attribute in your `Block` class to `record`, and then set
# it to use an instance of the new `Record` class that you created in the
# previous section. To do so, complete the following steps:
# 1. In the `Block` class, rename the `data` attribute to `record`.
# 2. Set the data type of the `record` attribute to `Record`.

@dataclass
class Block:
    record: Record
    creator_id: int
    prev_hash: str = "0"
    timestamp: str = datetime.datetime.utcnow().strftime("%H:%M:%S")
    nonce: int = 0

    def hash_block(self):
        sha = hashlib.sha256()

        record = str(self.record).encode()
        sha.update(record)

        creator_id = str(self.creator_id).encode()
        sha.update(creator_id)

        timestamp = str(self.timestamp).encode()

        prev_hash = str(self.prev_hash).encode()
        sha.update(prev_hash)

        nonce = str(self.nonce).encode
        sha.update(nonce)

        return sha.hexdigest()

@dataclass
class PyChain:
    chain: List[Block]
    difficulty: int = 4

    def proof_of_work(self, block):

        calculated_hash = block.hash_block()

        num_of_zeros = "0" * self.difficulty

        while not calculated_hash.startswith(num_of_zeros):

            block.nonce += 1

            calculated_hash = block.hash_block()

        print("Wining Hash", calculated_hash)
        return block

    def add_block(self, candidate_block):
        block = self.proof_of_work(candidate_block)
        self.chain += [block]

    def is_valid(self):
        block_hash = self.chain[0].hash_block()

        for block in self.chain[1:]:
            if block_hash != block.prev_hash:
                print("Blockchain is invalid!")
                return False

            block_hash = block.hash_block()

        print("Blockchain is Valid")
        return True

def my_func(arg1, arg2):
    # function body goes here
    pass

# Define hash function
def my_hash_func(func):
  func_code = inspect.getsource(func)
  return hash(func_code)

@st.cache(hash_funcs={types.FunctionType: lambda _: None}, allow_output_mutation=True)
def setup():
    print("Initializing Chain")
    return PyChain([Block("Genesis", 0)])

st.markdown("# PyChain")
st.markdown("## Store a Transaction Record in the PyChain")

pychain = setup()

# Step 3:
# Add Relevant User Inputs to the Streamlit Interface

# Code additional input areas for the user interface of your Streamlit
# application. Create these input areas to capture the sender, receiver, and
# amount for each transaction that youâ€™ll store in the `Block` record.
# To do so, complete the following steps:
# 1. Delete the `input_data` variable from the Streamlit interface.
# 2. Add an input area where you can get a value for `sender` from the user.
# 3. Add an input area where you can get a value for `receiver` from the user.
# 4. Add an input area where you can get a value for `amount` from the user.
# 5. As part of the Add Block button functionality, update `new_block` so that `Block` consists of an attribute named `record`, which is set equal to a `Record` that contains the `sender`, `receiver`, and `amount` values. The updated `Block`should also include the attributes for `creator_id` and `prev_hash`.

# @TODO:
# Delete the `input_data` variable from the Streamlit interface.
input_data = st.text_input("Block Data")

# @TODO:
# Add an input area where you can get a value for `sender` from the user.
sender = st.text_input("Sender")

# @TODO:
# Add an input area where you can get a value for `receiver` from the user.
receiver = st.text_input("Receiver")

# @TODO:
# Add an input area where you can get a value for `amount` from the user.
amount = st.text_input("Amount")

if st.button("Add Block"):
    prev_block = pychain.chain[-1]
    prev_block_hash = prev_block.hash_block()

    # @TODO
    # Update `new_block` so that `Block` consists of an attribute named `record`
    # which is set equal to a `Record` that contains the `sender`, `receiver`,
    # and `amount` values
    new_block = Block(
        data=input_data,
        record=Record(sender, receiver, amount),
        creator_id=42,
        prev_hash=prev_block_hash
    )

    pychain.add_block(new_block)
    st.balloons()

# Streamlit Code (continues)

st.markdown("## The PyChain Ledger")

pychain_df = pd.DataFrame(pychain.chain).astype(str)
st.write(pychain_df)

difficulty = st.sidebar.slider("Block Difficulty", 1, 5, 2)
pychain.difficulty = difficulty

st.sidebar.write("# Block Inspector")
selected_block = st.sidebar.selectbox(
    "Which block would you like to see?", pychain.chain
)

st.sidebar.write(selected_block)

if st.button("Validate Chain"):
    st.write(pychain.is_valid())
    print(pychain_df.head())

# Step 4:
# Test the PyChain Ledger by Storing Records

# Test your complete `PyChain` ledger and user interface by running your
# Streamlit application and storing some mined blocks in your `PyChain` ledger.
# Then test the blockchain validation process by using your `PyChain` ledger.
# Define the `Record` data class
class Record:
    def __init__(self, sender_address, recipient_address, value):
        self.sender_address = sender_address
        self.recipient_address = recipient_address
        self.value = value
        self.timestamp = dt.datetime.now()

    def to_dict(self):
        return {
            "sender_address": self.sender_address,
            "recipient_address": self.recipient_address,
            "value": self.value,
            "timestamp": self.timestamp,
        }

    def __str__(self):
        return f"{self.sender_address} sent {self.value} coins to {self.recipient_address} at {self.timestamp}"

# Define the `Block` data class
class Block:
    def __init__(self, record: Record, previous_hash: str):
        self.record = record.to_dict()
        self.previous_hash = previous_hash
        self.timestamp = dt.datetime.now()
        self.nonce = 0
        self.hash = self.compute_hash()

    def compute_hash(self):
        record_str = str(self.record)
        block_str = f"{self.previous_hash}{record_str}{self.timestamp}{self.nonce}"
        return hashlib.sha256(block_str.encode()).hexdigest()

    def __str__(self):
        return f"Block: {self.record}, {self.timestamp}, Nonce: {self.nonce}, Hash: {self.hash[:10]}..."

    def hash_block(self):
        record_str = str(self.record)
        record_encoded = record_str.encode()
        return hashlib.sha256(record_encoded).hexdigest()

# Define the `PyChain` class
class PyChain:
    def __init__(self):
        self.chain = [self.create_genesis_block()]
        self.difficulty = 2

    def create_genesis_block(self):
        return Block(Record("0", "0", 0), "0")

    def add_block(self, new_block):
        new_block.previous_hash = self.chain[-1].hash
        new_block.hash = new_block.compute_hash()
        self.proof_of_work(new_block)
        self.chain.append(new_block)

    def proof_of_work(self, block):
        block.nonce = 0
        while self.valid_proof(block) is False:
            block.nonce += 1

    def valid_proof(self, block):
        guess = str(block.hash + str(block.nonce)).encode()
        guess_hash = hashlib.sha256(guess).hexdigest()
        return guess_hash[:self.difficulty] == "0" * self.difficulty

    def is_valid(self):
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i - 1]
            if current_block.hash != current_block.compute_hash():
                return False
            if current_block.previous_hash != previous_block.hash:
                return False
            if not self.valid_proof(current_block):
                return False
        return True

# Define the Streamlit app

st.set_page_config(page_title="PyChain Ledger", page_icon=":guardsman:", layout="wide")

# Step 2: Set up the Streamlit App
pychain = PyChain()
pychain.create_genesis_block()


# Step 3: Add Relevant User Inputs to the Streamlit Interface
sender = st.text_input("Sender")
receiver = st.text_input("Receiver")
amount = st.text_input("Amount")

if st.button("Add Block"):
    prev_block = pychain.chain[-1]
    prev_block_hash = prev_block.hash_block()

    new_block = Block(
        record=Record(sender, receiver, amount),
        creator_id=42,
        prev_hash=prev_block_hash
    )

    pychain.add_block(new_block)
    st.balloons()


# Step 4: Test the PyChain Ledger by Storing Records
st.markdown("## The PyChain Ledger")

pychain_df = pd.DataFrame(pychain.chain).astype(str)
st.write(pychain_df)

difficulty = st.sidebar.slider("Block Difficulty", 1, 5, 2)
pychain.difficulty = difficulty

st.sidebar.write("# Block Inspector")
selected_block = st.sidebar.selectbox(
    "Which block would you like to see?", pychain.chain
)

st.sidebar.write(selected_block)

if st.button("Validate Chain"):
    st.write(pychain.is_valid())
    print(pychain_df.head())

################################################################################
# Step 4:
# Test the PyChain Ledger by Storing Records
# Test your complete `PyChain` ledger and user interface by running your
# Streamlit application and storing some mined blocks in your `PyChain` ledger.
# Then test the blockchain validation process by using your `PyChain` ledger.
# To do so, complete the following steps:
# 1. In the terminal, navigate to the project folder where you've coded the
#  Challenge.
# 2. In the terminal, run the Streamlit application by
# using `streamlit run pychain.py`.
# 3. Enter values for the sender, receiver, and amount, and then click the "Add
# Block" button. Do this several times to store several blocks in the ledger.
# 4. Verify the block contents and hashes in the Streamlit drop-down menu.
# Take a screenshot of the Streamlit application page, which should detail a
# blockchain that consists of multiple blocks. Include the screenshot in the
# `README.md` file for your Challenge repository.
# 5. Test the blockchain validation process by using the web interface.
# Take a screenshot of the Streamlit application page, which should indicate
# the validity of the blockchain. Include the screenshot in the `README.md`
# file for your Challenge repository.